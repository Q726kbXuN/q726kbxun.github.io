<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/png" sizes="16x16" href="spyglass.png"/>
<title>Word Frequencies</title>
<style>
:root{
    color-scheme: light dark;

    --bg-color:light-dark(#ededed, #121212);
    --card-color:light-dark(#e1e1e1, #1e1e1e);
    --text-color:light-dark(#1f1f1f, #e0e0e0);
    --accent-text:light-dark(#ffffff, #000000);
    --accent-color:light-dark(#00005f, #a0a0ff);
    --accent-hover:light-dark(#00003f, #c0c0ff);
    --border-color:light-dark(#cccccc, #333333);
    --secondary-color:light-dark(#d2d2d2, #2d2d2d);
    --error-color:light-dark(#993043, #cf6679);
    --highlight-color:light-dark(#ffffff, #ffffff);
    --highlight-background:light-dark(#3f3fbf, #4040c0);
}
*{
    margin:0;
    padding:0;
    box-sizing:border-box;
    font-family:"Roboto",sans-serif;
    font-size:12pt;
}
.segment{
    background-color: light-dark(#bbb, #444);
    padding: 6px;
    margin-bottom: 1em;
}
.clickable{
    cursor:pointer;
    color:var(--accent-color);
}
.clickable:hover{
    text-decoration:underline;
}
.target{
    background-color:var(--highlight-background);
    color:var(--highlight-color);
    box-shadow: 0.5ch 0.25ch var(--highlight-background), 0.5ch -0.25ch var(--highlight-background), -0.5ch 0.25ch var(--highlight-background), -0.5ch -0.25ch var(--highlight-background);
}
body{
    background-color:var(--bg-color);
    color:var(--text-color);
    min-height:100vh;
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:2rem;
}
.created{
    font-size:8pt;
    padding-top:0.25em;
}
.created span{
    font-size:8pt;
}
.container{
    width:100%;
}
header{
    margin-bottom:2rem;
    text-align:center;
}
.page-title {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 1rem;
}
.title-text p {
    font-size: 1rem;
    color: var(--text-color);
    opacity: 0.8;
    font-weight: 400;
}
h1{
    font-size:2.5rem;
    margin-bottom:0.5rem;
    color:var(--accent-color);
}
.search-card{
    background-color:var(--card-color);
    border-radius:8px;
    padding:2rem;
    box-shadow:0 4px 6px rgba(0,0,0,0.1);
    margin-bottom:2rem;
}
.search-form{
    display:flex;
    flex-direction:column;
    gap:1.2rem;
}
.search-bar {
    display:flex;
    gap:0.5rem;
}
.search-style {
    width:auto;
    flex:0 0 auto;
}
input[type=checkbox]:disabled {
  opacity: 0.25;
  cursor: not-allowed;
}
input[type=checkbox]:disabled+label{
    opacity: 0.25;
    cursor: not-allowed;
}
input[type="text"],select{
    flex:1;
    padding:0.75rem 1rem;
    font-size:1rem;
    background-color:var(--secondary-color);
    color:var(--text-color);
    border:1px solid var(--border-color);
    border-radius:4px;
    outline:none;
    transition:border-color 0.3s;
}
input[type="text"]:focus,select:focus {
    border-color:var(--accent-color);
}
select{
    cursor:pointer;
    appearance:none;
    padding-right:2rem;
    background-image:url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23e0e0e0' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat:no-repeat;
    background-position:right 0.7rem center;
    background-size:1rem;
}
button{
    padding:0.75rem 1.5rem;
    font-size:1rem;
    background-color:var(--accent-color);
    color:var(--accent-text);
    border:none;
    border-radius:4px;
    cursor:pointer;
    transition:background-color 0.3s;
}
button:hover{
    background-color:var(--accent-hover);
}
.search-options{
    display:flex;
    flex-wrap:wrap;
    gap:1.5rem;
}
.option-group{
    min-width:200px;
}
.option-label{
    font-size:0.9rem;
    font-weight:600;
    margin-bottom:0.5rem;
    display:block;
    color:var(--accent-color);
}
.time-inputs{
    display:flex;
    gap:1rem;
}
.time-input{
    flex:1;
}
.time-input input{
    width:10em;
}
.checkbox-group{
    display:flex;
    align-items:center;
    gap:0.5rem;
    margin-top:0.5rem;
}
input[type="checkbox"]{
    appearance:none;
    width:18px;
    height:18px;
    border:2px solid var(--border-color);
    border-radius:3px;
    background-color:var(--secondary-color);
    cursor:pointer;
    position:relative;
}
input[type="checkbox"]:checked{
    background-color:var(--accent-color);
    border-color:var(--accent-color);
}
input[type="checkbox"]:checked::after{
    content:"";
    position:absolute;
    left:5px;
    top:2px;
    width:5px;
    height:10px;
    border:solid var(--accent-text);
    border-width:0 2px 2px 0;
    transform:rotate(45deg);
}
.results-container{
    background-color:var(--card-color);
    border-radius:8px;
    padding:1.5rem;
    box-shadow:0 4px 6px rgba(0,0,0,0.1);
}
.results-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:1.5rem;
    padding-bottom:0.75rem;
    border-bottom:1px solid var(--border-color);
}
.result-stats{
    font-size:0.9rem;
    color:var(--text-color);
}
.result-sort{
    display:flex;
    align-items:center;
    gap:0.5rem;
}
.result-sort select{
    padding:0.5rem;
    font-size:0.9rem;
}
.result-item{
    padding:1.2rem;
    border-bottom:1px solid var(--border-color);
}
.result-item:last-child{
    border-bottom:none;
}
.result-title{
    font-size:1.2rem;
    margin-bottom:0.5rem;
    color:var(--accent-color);
}
.result-title a{
    color:var(--accent-color);
    text-decoration:none;
}
.result-title a:hover{
    text-decoration:underline;
}
.result-description{
    font-size:0.95rem;
    line-height:1.5;
}
.pagination{
    display:flex;
    justify-content:center;
    margin-top:2rem;
    gap:0.5rem;
}
.page-btn{
    padding:0.5rem 1rem;
    background-color:var(--secondary-color);
    color:var(--text-color);
    border:1px solid var(--border-color);
    border-radius:4px;
    cursor:pointer;
    transition:all 0.3s;
}
.page-btn:hover:not(.active){
    background-color:light-dark(#ccc, #333);
}
.page-btn.active{
    background-color:var(--accent-color);
    border-color:var(--accent-color);
    color:var(--accent-text);
}
.quick-links{
    display:flex;
    gap:1.5rem;
    margin-top:1.2rem;
}
.quick-link{
    color:var(--accent-color);
    text-decoration:none;
    font-size:0.95rem;
    position:relative;
    transition:color 0.2s;
}
.quick-link:hover{
    color:var(--accent-hover);
    text-decoration:underline;
}
.quick-link::after{
    content:"\2192";
    position:relative;
    display:inline-block;
    margin-left:4px;
    transition:transform 0.2s;
}
.quick-link:hover::after{
    transform:translateX(3px);
}
.hit{
    margin-bottom:0.5em;
    line-height:125%;
    text-indent:-2em;
    margin-left:2em;
}

button.remove-word-btn {
    padding: 0.2rem 0.5rem;
    font-size: 0.8rem;
    background-color: var(--error-color);
    margin-left: 0.5rem;
}
.radio-group{
    display: flex;
    gap: 1.5rem;
    align-items: center;
    flex-wrap: wrap;
}
.radio-group label {
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
input[type="radio"] {
    appearance: none;
    width: 18px;
    height: 18px;
    border: 2px solid var(--border-color);
    border-radius: 50%;
    background-color: var(--secondary-color);
    cursor: pointer;
    position: relative;
}
input[type="radio"]:checked {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
}
input[type="radio"]:checked::after {
    content: "";
    position: absolute;
    top: 4px;
    left: 4px;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: var(--accent-text);
}
.word-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
}
.word-tag {
    display: inline-flex;
    align-items: center;
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    background-color: var(--secondary-color);
    border: 1px solid var(--border-color);
}
.word-color-swatch {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 0.5rem;
    border: 1px solid var(--text-color);
}
#chart-container {
    width: 100%;
    overflow-x: auto;
    min-height: 400px;
}
.axis path, .axis line {
    fill: none;
    stroke: var(--text-color);
    shape-rendering: crispEdges;
}
.axis text {
    fill: var(--text-color);
    font-size: 10pt;
}
.grid-line {
    stroke: var(--border-color);
    stroke-opacity: 0.7;
    shape-rendering: crispEdges;
}
.tooltip {
    position: absolute;
    background-color: var(--secondary-color);
    border: 1px solid var(--border-color);
    padding: 8px;
    border-radius: 4px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    font-size: 0.9rem;
    white-space: nowrap;
    z-index: 1000;
}
.tooltip.show {
    opacity: 0.95;
    pointer-events: auto;
}
.tooltip a {
    color: var(--accent-color);
    text-decoration: none;
}
.tooltip a:hover {
    text-decoration: underline;
}
@media(max-width:768px){
    body{
        padding:0.5rem;
    }
    .page-title {
        flex-direction: column;
        gap: 0.75rem;
        padding: 1rem 0;
    }
    .search-bar{
        flex-direction:column;
    }
    .search-options{
        flex-direction:column;
        gap:1rem;
    }
    .option-group{
        width:100%;
    }
    .search-card,.results-container{
        border-radius:4px;
        padding:1rem;
    }
    .result-item{
        padding:0.8rem;
    }
    .search-form{
        gap:0.8rem;
    }
    .hit{
        text-indent:-1em;
        margin-left:1em;
    }
    .radio-group{
        flex-direction:column;
        align-items:flex-start;
        gap:0.75rem;
    }
}
</style>
<script>
let info = null;
let batches = null;
let batchData = {};
const frequencyCache = {};

async function fetchWithRetry(url, start, len) {
    const isChrome = navigator.userAgent.toLowerCase().includes('chrome');
    if (!isChrome) {
        const resp = await fetch(url);
        if (!resp.ok) {
            throw new Error(`HTTP error! status: ${resp.status}`);
        }
        const fullBlob = await resp.blob();
        const endByte = Math.min(start + len, fullBlob.size);
        const subsetBlob = fullBlob.slice(start, endByte);
        return subsetBlob;
    }
    
    const chunks = [];
    let currentStart = start;
    let remainingBytes = len;
    
    while (remainingBytes > 0) {
        const chunkEnd = currentStart + remainingBytes - 1;
        const resp = await fetch(
            url,
            {
                'headers': {
                    'Range': `bytes=${currentStart}-${chunkEnd}`,
                },
            }
        );
        if (!resp.ok) {
            throw new Error(`HTTP error! status: ${resp.status}`);
        }
        const chunk = await resp.blob();
        if (chunk.size === 0) {
            throw new Error(`Request returned 0 bytes for range ${currentStart}-${chunkEnd}`);
        }
    
        chunks.push(chunk);
        const bytesReceived = chunk.size;
        currentStart += bytesReceived;
        remainingBytes -= bytesReceived;
    }
    return new Blob(chunks);
}

async function getData(data_num, start, len, loadMode='gzipDecode') {
    let data;
    if (Number.isFinite(data_num)) {
        const url = "./search_data_" + String(data_num).padStart(2, '0') + ".dat";
        data = await fetchWithRetry(url, start, len);
    } else {
        const resp = await fetch("./search_data_" + data_num + ".dat");
        data = await resp.blob();
    }

    if (loadMode == 'gzipDecode') {
        const ds = new DecompressionStream("gzip");
        const decomp = data.stream().pipeThrough(ds);
        const decoded = await new Response(decomp).blob();
        const text = await decoded.text();
        return JSON.parse(text);
    } else if (loadMode == 'json') {
        const text = await data.text();
        return JSON.parse(text);
    }
}

function escapeRe(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

async function cacheLoad(batchInfo) {
    let key = batchInfo.join('|');
    if (!(key in batchData)) {
        batchData[key] = await getData(...batchInfo);
    }
    return batchData[key];
}

document.addEventListener("DOMContentLoaded", function(event) {
    const chartState = {
        words: new Map(),
        granularity: 'daily'
    };
    
    let isUpdatingHash = false;
    let tooltipTimeout = null;
    const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
    
    const wordInput = document.getElementById('wordInput');
    const addWordBtn = document.getElementById('addWordBtn');
    const clearBtn = document.getElementById('clearBtn');
    const granularityRadios = document.querySelectorAll('input[name="granularity"]');
    const chartContainer = document.getElementById('chart-container');
    const wordListDiv = document.getElementById('wordList');
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);

    async function initialize() {
        if (info === null) {
            info = await getData(0, 0, 100, "json");
            batches = await getData(...info.data);
        }
        await parseURLHash();
    }

    async function getFrequencyForWord(word) {
        const lowerCaseWord = word.toLowerCase();
        if (frequencyCache[lowerCaseWord]) {
            return frequencyCache[lowerCaseWord];
        }

        const regex = new RegExp('\\b' + escapeRe(lowerCaseWord) + '\\b', 'gi');
        const dailyCounts = new Map();

        for (const batchInfo of batches) {
            const batch = await cacheLoad(batchInfo);
            for (const item of batch) {
                if (item.published === '1970-01-01') continue;
                
                const matches = (item.words.toLowerCase().match(regex) || []).length;
                if (matches > 0) {
                    const existing = dailyCounts.get(item.published);
                    const count = (existing ? existing.count : 0) + matches;
                    dailyCounts.set(item.published, { count, link: item.link });
                }
            }
        }
        
        const sortedData = Array.from(dailyCounts.entries())
            .map(([date, data]) => ({ date: new Date(date + 'T00:00:00'), ...data }))
            .sort((a, b) => a.date - b.date);
            
        frequencyCache[lowerCaseWord] = sortedData;
        return sortedData;
    }
    
    function updateWordListView() {
        wordListDiv.innerHTML = '';
        chartState.words.forEach((wordData, word) => {
            const tag = document.createElement('div');
            tag.className = 'word-tag';
            
            const swatch = document.createElement('div');
            swatch.className = 'word-color-swatch';
            swatch.style.backgroundColor = wordData.color;
            
            const text = document.createElement('span');
            text.textContent = word;

            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-word-btn';
            removeBtn.textContent = '×';
            removeBtn.onclick = () => removeWord(word);

            tag.appendChild(swatch);
            tag.appendChild(text);
            tag.appendChild(removeBtn);
            wordListDiv.appendChild(tag);
        });
    }

    function renderChart() {
        chartContainer.innerHTML = '';
        if (chartState.words.size === 0) {
            chartContainer.innerHTML = '<p style="text-align:center; padding: 2rem;">Add a word to start visualizing its frequency.</p>';
            return;
        }

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        const svgWidth = chartContainer.clientWidth;
        const svgHeight = 500;
        const margin = { top: 20, right: 30, bottom: 70, left: 50 };
        const chartWidth = svgWidth - margin.left - margin.right;
        const chartHeight = svgHeight - margin.top - margin.bottom;

        svg.setAttribute('width', svgWidth);
        svg.setAttribute('height', svgHeight);
        
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
        svg.appendChild(g);

        let allData = [];
        chartState.words.forEach(wordData => {
            allData = allData.concat(aggregateData(wordData.dailyData));
        });

        if (allData.length === 0) {
            chartContainer.innerHTML = '<p style="text-align:center; padding: 2rem;">No data found for the tracked words.</p>';
            return;
        }

        const xMin = new Date(Math.min(...allData.map(d => d.date)));
        const xMax = new Date(Math.max(...allData.map(d => d.date)));
        const yMax = Math.max(10, ...allData.map(d => d.count));
        
        const xScale = (date) => (date - xMin) / (xMax - xMin) * chartWidth;
        const yScale = (val) => chartHeight - (val / yMax) * chartHeight;

        drawAxes(g, xScale, yScale, xMin, xMax, yMax, chartWidth, chartHeight);

        chartState.words.forEach((wordData, word) => {
            const aggregatedData = aggregateData(wordData.dailyData);
            if (aggregatedData.length === 0) return;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = aggregatedData.map((p, i) => 
                `${i === 0 ? 'M' : 'L'} ${xScale(p.date)} ${yScale(p.count)}`
            ).join(' ');
            path.setAttribute('d', d);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', wordData.color);
            path.setAttribute('stroke-width', 2);
            g.appendChild(path);

            aggregatedData.forEach(p => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', xScale(p.date));
                circle.setAttribute('cy', yScale(p.count));
                circle.setAttribute('r', 4);
                circle.setAttribute('fill', wordData.color);
                
                circle.dataset.word = word;
                circle.dataset.count = p.count;
                circle.dataset.date = p.date.toISOString().split('T')[0];
                if (chartState.granularity === 'daily' && p.link) {
                    circle.dataset.link = p.link;
                }
                
                circle.addEventListener('mouseover', handleMouseOver);
                circle.addEventListener('mousemove', handleMouseMove);
                circle.addEventListener('mouseleave', handleMouseLeave);
                
                g.appendChild(circle);
            });
        });
        chartContainer.appendChild(svg);
    }
    
    function drawAxes(g, xScale, yScale, xMin, xMax, yMax, width, height) {
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        yAxis.setAttribute('class', 'axis');
        const numYTicks = 5;
        for (let i = 0; i <= numYTicks; i++) {
            const val = (yMax / numYTicks) * i;
            const y = yScale(val);
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('class', 'grid-line');
            line.setAttribute('x1', 0);
            line.setAttribute('x2', width);
            line.setAttribute('y1', y);
            line.setAttribute('y2', y);
            yAxis.appendChild(line);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', -10);
            text.setAttribute('y', y + 4);
            text.setAttribute('text-anchor', 'end');
            text.textContent = Math.round(val);
            yAxis.appendChild(text);
        }
        g.appendChild(yAxis);

        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        xAxis.setAttribute('class', 'axis');
        xAxis.setAttribute('transform', `translate(0,${height})`);
        const timeDiff = xMax.getTime() - xMin.getTime();
        const numXTicks = Math.min(10, Math.floor(width / 80));
        
        for (let i = 0; i <= numXTicks; i++) {
            const date = new Date(xMin.getTime() + (timeDiff / numXTicks) * i);
            const x = xScale(date);
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x);
            line.setAttribute('x2', x);
            line.setAttribute('y1', 0);
            line.setAttribute('y2', 5);
            xAxis.appendChild(line);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', 20);
            text.setAttribute('text-anchor', 'middle');
            text.textContent = date.toLocaleDateString(undefined, { year: 'numeric', month: 'short' });
            
            if (width < 500) {
                 text.setAttribute('transform', `rotate(-45, ${x}, 20)`);
                 text.setAttribute('text-anchor', 'end');
            }
            
            xAxis.appendChild(text);
        }
        g.appendChild(xAxis);
    }
    
    function aggregateData(dailyData) {
        if (chartState.granularity === 'daily') return dailyData;
        
        const aggregated = new Map();
        dailyData.forEach(d => {
            let keyDate;
            if (chartState.granularity === 'weekly') {
                const date = new Date(d.date);
                date.setDate(date.getDate() - date.getDay());
                keyDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            } else {
                keyDate = new Date(d.date.getFullYear(), d.date.getMonth(), 1);
            }
            const key = keyDate.toISOString();
            const current = aggregated.get(key) || { count: 0, date: keyDate };
            current.count += d.count;
            aggregated.set(key, current);
        });
        return Array.from(aggregated.values()).sort((a,b) => a.date - b.date);
    }

    function showTooltip(e) {
        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
        tooltip.classList.add('show');
        const { word, count, date, link } = e.target.dataset;
        let content = `<strong>${word}</strong><br>
                       Count: ${count}<br>
                       Date: ${date}`;
        if (link) {
            content += `<br><a href="${link}" target="_blank">View Episode</a>`;
        }
        tooltip.innerHTML = content;
    }

    function hideTooltip() {
        tooltipTimeout = setTimeout(() => {
            tooltip.classList.remove('show');
        }, 200);
    }

    function handleMouseOver(e) {
        showTooltip(e);
    }
    
    function handleMouseMove(e) {
        tooltip.style.left = `${e.pageX + 15}px`;
        tooltip.style.top = `${e.pageY + 15}px`;
    }

    function handleMouseLeave() {
        hideTooltip();
    }

    tooltip.addEventListener('mouseenter', () => {
        if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = null;
        }
    });

    tooltip.addEventListener('mouseleave', hideTooltip);

    async function addWord(word) {
        word = word.trim();
        if (!word || chartState.words.has(word)) {
            wordInput.value = '';
            return;
        }

        const wordData = {
            color: colors[chartState.words.size % colors.length],
            dailyData: await getFrequencyForWord(word)
        };
        chartState.words.set(word, wordData);
        
        wordInput.value = '';
        updateWordListView();
        renderChart();
        updateURLHash();
    }
    
    function removeWord(word) {
        chartState.words.delete(word);
        updateWordListView();
        renderChart();
        updateURLHash();
    }
    
    function clearAll() {
        chartState.words.clear();
        updateWordListView();
        renderChart();
        updateURLHash();
         }

    function updateURLHash() {
        isUpdatingHash = true;
        const params = new URLSearchParams();
        params.set('granularity', chartState.granularity);
        const words = Array.from(chartState.words.keys());
        if (words.length > 0) {
            params.set('words', words.join(','));
        }
        window.location.hash = params.toString();
        setTimeout(() => { isUpdatingHash = false; }, 100);
    }

    async function parseURLHash() {
        if (isUpdatingHash) return;
        
        const params = new URLSearchParams(window.location.hash.substring(1));
        
        const granularity = params.get('granularity') || 'daily';
        chartState.granularity = granularity;
        document.getElementById(granularity).checked = true;

        const words = params.get('words');
        const wordsToAdd = words ? words.split(',') : [];
        
        const currentWords = new Set(chartState.words.keys());
        const wordsToRemove = [...currentWords].filter(w => !wordsToAdd.includes(w));
        wordsToRemove.forEach(w => chartState.words.delete(w));

        for (const word of wordsToAdd) {
            if (!chartState.words.has(word)) {
                const wordData = {
                    color: colors[chartState.words.size % colors.length],
                    dailyData: await getFrequencyForWord(word)
                };
                chartState.words.set(word, wordData);
            }
        }
        
        updateWordListView();
        renderChart();
    }
    
    addWordBtn.addEventListener('click', () => addWord(wordInput.value));
    wordInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            addWord(wordInput.value);
        }
    });
    
    clearBtn.addEventListener('click', clearAll);

    granularityRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
            chartState.granularity = e.target.value;
            renderChart();
            updateURLHash();
        });
    });

    window.addEventListener('hashchange', parseURLHash);
    window.addEventListener('resize', renderChart);
    
    initialize();
});
</script>
</head>
<body>
<div class="container">
    <div class="search-card">
        <div class="search-form">
            <div class="search-bar">
                <input id="wordInput" type="text" placeholder="Enter a word to track..." autocomplete="off">
                <button id="addWordBtn">Add Word</button>
                <button id="clearBtn" style="background-color: var(--error-color);">Clear All</button>
            </div>
            <div class="option-group">
                <label class="option-label">Frequency</label>
                <div class="radio-group">
                     <label><input type="radio" id="daily" name="granularity" value="daily" checked> Daily</label>
                     <label><input type="radio" id="weekly" name="granularity" value="weekly"> Weekly</label>
                     <label><input type="radio" id="monthly" name="granularity" value="monthly"> Monthly</label>
                </div>
            </div>
            <div id="wordListContainer" class="option-group">
                <label class="option-label">Tracked Words</label>
                <div id="wordList" class="word-list"></div>
            </div>
        </div>
    </div>
    
    <div class="results-container">
        <div id="chart-container">
            <p style="text-align:center; padding: 2rem;">Add a word to start visualizing its frequency.</p>
        </div>
    </div>
</div>
</body>
</html>
